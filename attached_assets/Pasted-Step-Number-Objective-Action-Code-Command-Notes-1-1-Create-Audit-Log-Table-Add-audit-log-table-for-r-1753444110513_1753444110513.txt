Step Number	Objective	Action	Code/Command	Notes
1.1	Create Audit Log Table	Add audit log table for report access tracking.	Add to shared/schema.ts: `import { pgTable, text, timestamp } from "drizzle-orm/pg-core"; import { createId } from "@paralleldrive/cuid2"; export const auditLog = pgTable("audit_log", { id: text("id").primaryKey().$defaultFn(() => createId()), userId: text("userId").notNull(), action: text("action").notNull(), timestamp: timestamp("timestamp").notNull().defaultNow(), });` && npm run db:push	Requires `npm install @paralleldrive/cuid2` for IDs. Enhances discretion. For SQLite, use: `db.exec(\`CREATE TABLE audit_log (id TEXT PRIMARY KEY, userId TEXT, action TEXT, timestamp TEXT)\`);`
1.2	Expand Reports API	Add comprehensive metrics including new features.	echo 'import type { NextApiRequest, NextApiResponse } from "next"; import { getSession } from "../../lib/auth"; import { drizzle } from "drizzle-orm/neon-http"; import { neon } from "@neondatabase/serverless"; import { bookings, inquiries, rooms, inventory, maintenance, master_codes, banned_list } from "../../shared/schema"; const sql = neon(process.env.DATABASE_URL!); const db = drizzle(sql); export default async function handler(req: NextApiRequest, res: NextApiResponse) { const session = await getSession(req, res); if (!session || session.user.role !== "admin") { return res.status(403).json({ error: "Forbidden" }); } if (req.method === "GET") { await db.insert(auditLog).values({ id: createId(), userId: session.user.id, action: "accessed_reports", timestamp: new Date() }); const lowSupplies = await db.select().from(inventory).where(lte(inventory.quantity, inventory.threshold)); const repairs = await db.select().from(maintenance).where(eq(maintenance.status, "open")); const nonCompliantBookings = await db.select().from(bookings).where(and(lt(sql`(julianday(endDate) - julianday(startDate))`, 30), ne(bookings.plan, "month"))); const pendingPayments = await db.select().from(bookings).where(eq(bookings.paymentStatus, "pending")); const inquiriesSummary = await db.select({ status: inquiries.status, count: count() }).from(inquiries).groupBy(inquiries.status); const cleaningIssues = await db.select().from(rooms).where(or(ne(rooms.cleaningStatus, "clean"), ne(rooms.linenStatus, "fresh"))); const masterCodes = await db.select().from(master_codes); const bannedList = await db.select().from(banned_list); return res.status(200).json({ lowSupplies, repairs, nonCompliantBookings, pendingPayments, inquiriesSummary, cleaningIssues, masterCodes, bannedList }); } }' > server/routes/reports.ts	Requires Drizzle ORM imports. For SQLite, replace with: `const lowSupplies = db.prepare("SELECT * FROM inventory WHERE quantity <= threshold").all();` etc.
1.3	Create Reports UI	Add mobile-friendly reports page.	echo 'import { useSession } from "next-auth/react"; import { useQuery } from "@tanstack/react-query"; import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"; import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"; export default function Reports() { const { data: session } = useSession(); const { data: report } = useQuery({ queryKey: ["reports"], queryFn: async () => (await fetch("/api/reports")).json(), enabled: !!session }); if (!session || session.user.role !== "admin") return <div className="p-4 text-center">Access denied</div>; if (!report) return <div className="p-4 text-center">Loading...</div>; return ( <div className="p-4 max-w-4xl mx-auto space-y-6"> <h1 className="text-2xl font-bold">Admin Reports</h1> <Card> <CardHeader><CardTitle>Low Supplies</CardTitle></CardHeader> <CardContent> <Table> <TableHeader><TableRow><TableHead>Item</TableHead><TableHead>Quantity</TableHead><TableHead>Threshold</TableHead></TableRow></TableHeader> <TableBody>{report.lowSupplies.map(item => (<TableRow key={item.id}><TableCell>{item.item}</TableCell><TableCell>{item.quantity}</TableCell><TableCell>{item.threshold}</TableCell></TableRow>))}</TableBody> </Table> </CardContent> </Card> <Card> <CardHeader><CardTitle>Open Repairs</CardTitle></CardHeader> <CardContent> <Table> <TableHeader><TableRow><TableHead>Room</TableHead><TableHead>Issue</TableHead><TableHead>Reported</TableHead></TableRow></TableHeader> <TableBody>{report.repairs.map(repair => (<TableRow key={repair.id}><TableCell>{repair.roomId}</TableCell><TableCell>{repair.issue}</TableCell><TableCell>{repair.dateReported}</TableCell></TableRow>))}</TableBody> </Table> </CardContent> </Card> <Card> <CardHeader><CardTitle>Non-Compliant Bookings (Bill 41)</CardTitle></CardHeader> <CardContent> <Table> <TableHeader><TableRow><TableHead>Booking ID</TableHead><TableHead>Room</TableHead><TableHead>Days</TableHead></TableRow></TableHeader> <TableBody>{report.nonCompliantBookings.map(b => (<TableRow key={b.id}><TableCell>{b.id}</TableCell><TableCell>{b.roomId}</TableCell><TableCell>{Math.floor((new Date(b.endDate) - new Date(b.startDate)) / (1000 * 3600 * 24))}</TableCell></TableRow>))}</TableBody> </Table> </CardContent> </Card> <Card> <CardHeader><CardTitle>Pending Payments</CardTitle></CardHeader> <CardContent> <Table> <TableHeader><TableRow><TableHead>Booking ID</TableHead><TableHead>Room</TableHead><TableHead>Plan</TableHead></TableRow></TableHeader> <TableBody>{report.pendingPayments.map(b => (<TableRow key={b.id}><TableCell>{b.id}</TableCell><TableCell>{b.roomId}</TableCell><TableCell>{b.plan}</TableCell></TableRow>))}</TableBody> </Table> </CardContent> </Card> <Card> <CardHeader><CardTitle>Inquiry Statuses</CardTitle></CardHeader> <CardContent> <Table> <TableHeader><TableRow><TableHead>Status</TableHead><TableHead>Count</TableHead></TableRow></TableHeader> <TableBody>{report.inquiriesSummary.map(i => (<TableRow key={i.status}><TableCell>{i.status}</TableCell><TableCell>{i.count}</TableCell></TableRow>))}</TableBody> </Table> </CardContent> </Card> <Card> <CardHeader><CardTitle>Cleaning/Linen Issues</CardTitle></CardHeader> <CardContent> <Table> <TableHeader><TableRow><TableHead>Room</TableHead><TableHead>Cleaning</TableHead><TableHead>Linen</TableHead></TableRow></TableHeader> <TableBody>{report.cleaningIssues.map(r => (<TableRow key={r.id}><TableCell>{r.id}</TableCell><TableCell>{r.cleaningStatus}</TableCell><TableCell>{r.linenStatus}</TableCell></TableRow>))}</TableBody> </Table> </CardContent> </Card> <Card> <CardHeader><CardTitle>Master Door Codes</CardTitle></CardHeader> <CardContent> <Table> <TableHeader><TableRow><TableHead>Property</TableHead><TableHead>Master Code</TableHead><TableHead>Last Updated</TableHead><TableHead>Notes</TableHead></TableRow></TableHeader> <TableBody>{report.masterCodes.map(c => (<TableRow key={c.id}><TableCell>{c.property}</TableCell><TableCell>{c.masterCode}</TableCell><TableCell>{c.lastUpdated}</TableCell><TableCell>{c.notes}</TableCell></TableRow>))}</TableBody> </Table> </CardContent> </Card> <Card> <CardHeader><CardTitle>Banned Individuals</CardTitle></CardHeader> <CardContent> <Table> <TableHeader><TableRow><TableHead>Name</TableHead><TableHead>Phone</TableHead><TableHead>Email</TableHead><TableHead>Reason</TableHead></TableRow></TableHeader> <TableBody>{report.bannedList.map(b => (<TableRow key={b.id}><TableCell>{b.name}</TableCell><TableCell>{b.phone}</TableCell><TableCell>{b.email}</TableCell><TableCell>{b.reason}</TableCell></TableRow>))}</TableBody> </Table> </CardContent> </Card> </div> ); }' > client/src/pages/reports.tsx	Uses shadcn/ui for mobile-friendly tables.
1.4	Add Reports to Navigation	Add reports link to UI.	Add to client/src/components/Navbar.tsx: `<NavLink to="/reports" className="block p-2 hover:bg-gray-700 text-white">Reports</NavLink>` after `<NavLink to="/banned_list">`	Assumes Wouter for routing; adjust for your nav setup.
2.1	Ensure Schema Compatibility	Add master_codes and banned_list to schema.	Add to shared/schema.ts: `export const master_codes = pgTable("master_codes", { id: text("id").primaryKey().$defaultFn(() => createId()), property: text("property").notNull(), masterCode: text("masterCode").notNull(), lastUpdated: timestamp("lastUpdated").notNull().defaultNow(), notes: text("notes"), }); export const banned_list = pgTable("banned_list", { id: text("id").primaryKey().$defaultFn(() => createId()), name: text("name"), phone: text("phone"), email: text("email"), reason: text("reason").notNull(), bannedDate: timestamp("bannedDate").notNull().defaultNow(), });` && npm run db:push	Matches your new requirements. For SQLite, use: `db.exec(\`CREATE TABLE master_codes ...\`);` from previous guide.
2.2	Update Inquiries Schema	Add email field for banned list checks.	Add to shared/schema.ts: `export const inquiries = pgTable("inquiries", { ..., email: text("email").notNull(), ... });` && npm run db:push	Ensures inquiries support email blocking.
3.1	Optimize for Mobile	Add responsive styles to reports page.	Add to client/src/styles/globals.css: `.responsive-table { overflow-x: auto; } .responsive-table table { min-width: 100%; } @media (max-width: 640px) { .responsive-table th, .responsive-table td { font-size: 0.875rem; padding: 0.5rem; } }` && Wrap tables in pages/reports.tsx with: `<div className="responsive-table">`	Enhances mobile usability with shadcn/ui and Tailwind.
3.2	Validate Data	Add data freshness check.	Add to server/routes/reports.ts: `const isStale = (date: string) => new Date(date) < new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); const staleSupplies = lowSupplies.filter(s => isStale(s.lastUpdated)); const staleRepairs = repairs.filter(r => isStale(r.dateReported)); if (staleSupplies.length || staleRepairs.length) { return res.status(200).json({ ...report, warnings: { staleSupplies, staleRepairs } }); }`	Adds warning for data older than 7 days.